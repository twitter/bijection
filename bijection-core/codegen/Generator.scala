// Run this generator like a script:
// scala Generator.scala > ../src/main/scala/com/twitter/bijection/GeneratedTupleBijections.scala
val pkg = "package com.twitter.bijection"

/* Example of the code generated:
  implicit def tuple2[A1,B1,A2,B2](implicit ba: Bijection[A1,A2], bb: Bijection[B1,B2]):
    Bijection[(A1,B1),(A2,B2)] = new AbstractBijection[(A1,B1),(A2,B2)] {
      def apply(in: (A1,B1)) = (ba(in._1), bb(in._2))
      def invert(out: (A2,B2)) = (ba.invert(out._1), bb.invert(out._2))
    }

  // For Injection:
  implicit def tuple2[A1,B1,A2,B2](implicit ba: Injection[A1,A2], bb: Injection[B1,B2]):
    Injection[(A1,B1),(A2,B2)] = new AbstractInjection[(A1,B1),(A2,B2)] {
      def apply(in: (A1,B1)) = (ba(in._1), bb(in._2))
      def invert(out: (A2,B2)) =
        for(a <- ba.invert(out._1);
            b <- bb.invert(out._2)
            ) yield (a,b)
    }
*/

val lowerLetters = ('a' to 'z').toIndexedSeq
val upperLetters = ('A' to 'Z').toIndexedSeq

def bijectionParameter(i: Int, typeStr: String = "Bijection"): String = {
  val l = lowerLetters(i)
  val U = upperLetters(i)
  "b" + l + ": " + typeStr +"[" + U + "1," + U + "2]"
}

def typeList(cnt: Int, suffix: String) =
  upperLetters.slice(0, cnt) map { l => l.toString + suffix } mkString(",")

def tupleBijectionType(cnt: Int, typeStr: String = "Bijection"): String =
  typeStr + "[(" + typeList(cnt, "1") + "), (" + typeList(cnt, "2") + ")]"

def applyPart(i: Int): String = "b" + lowerLetters(i) + "(in._" + (i+1) + ")"
def invertPart(i: Int): String = "b" + lowerLetters(i) + ".invert(out._" + (i+1) + ")"
def forInvertPart(i: Int): String = lowerLetters(i) + " <- " + invertPart(i)

def expressionTuple(cnt: Int, sep: String = ", ")(part: (Int) => String) =
  (0 until cnt) map { part(_) } mkString("(", sep, ")")

def applyMethod(cnt: Int) =
  "def apply(in: (" + typeList(cnt,"1") + ")) = " + expressionTuple(cnt) { applyPart _ }

def invertMethod(cnt: Int) =
  "override def invert(out: (" + typeList(cnt,"2") + ")) = " + expressionTuple(cnt) { invertPart _ }

// Here we put it all together:
def implicitTuple(cnt: Int): String =
  "  implicit def tuple" + cnt + "[" + typeList(cnt,"1") + "," + typeList(cnt,"2") +
    "](implicit " + ((0 until cnt) map { bijectionParameter(_) } mkString(", ") ) + "):\n    " +
    tupleBijectionType(cnt) + " = new Abstract" + tupleBijectionType(cnt) + " {\n" +
"      " + applyMethod(cnt) +"\n" +
"      " + invertMethod(cnt) + "\n" +
"    }"

def invertInj(cnt: Int) =
  "def invert(out: (" + typeList(cnt,"2") + ")) = for" +
    expressionTuple(cnt, "; ") { forInvertPart _ } + " yield (" +
      lowerLetters.slice(0, cnt).mkString(",") + ")"

// For the Injections:
def implicitTupleInj(cnt: Int): String =
  "  implicit def tuple" + cnt + "[" + typeList(cnt,"1") + "," + typeList(cnt,"2") +
    "](implicit " + ((0 until cnt) map { bijectionParameter(_, "Injection") } mkString(", ") ) + "):\n    " +
    tupleBijectionType(cnt, "Injection") + " = new Abstract" + tupleBijectionType(cnt, "Injection") + " {\n" +
"      " + applyMethod(cnt) +"\n" +
"      " + invertInj(cnt) + "\n" +
"    }"


println("// Autogenerated code DO NOT EDIT BY HAND")
println(pkg)
println("\ntrait GeneratedTupleBijections extends LowPriorityBijections {")
(2 to 22).foreach { cnt => println(implicitTuple(cnt)) }
println("}")

println("\ntrait GeneratedTupleInjections extends LowPriorityInjections {")
(2 to 22).foreach { cnt => println(implicitTupleInj(cnt)) }
println("}")

